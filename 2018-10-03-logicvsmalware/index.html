<!DOCTYPE html><html lang="en"><head><meta name="generator" content="Hexo 3.9.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>Logic &amp; binaries | barbie's notes</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.1"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/normalize.css/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/purecss/build/pure-min.min.css"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/purecss/build/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.jsdelivr.net/npm/jquery/dist/jquery.min.js"></script><link rel="icon" mask sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><script type="text/javascript" src="//cdn.jsdelivr.net/npm/clipboard/dist/clipboard.min.js"></script><script type="text/javascript" src="//cdn.jsdelivr.net/gh/codeseven/toastr/build/toastr.min.js"></script><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/codeseven/toastr/build/toastr.min.css"><link rel="stylesheet" href="/css/prism.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Logic &amp; binaries</h1><a id="logo" href="/.">barbie's notes</a><p class="description">my not-professional-at-all blog</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> start</i></a><a href="/archives/"><i class="fa fa-archive"> oldies</i></a><a href="/about/"><i class="fa fa-user"> /me</i></a><a href="/talks/"><i class="fa fa-users"> IRL</i></a><a href="/credits/"><i class="fa fa-heart"> credits</i></a><a href="/atom.xml"><i class="fa fa-rss"> RSS</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Logic &amp; binaries</h1><div class="post-meta">2018-10-04<span class="post-time"><span class="post-meta-item-text"> | </span><span class="post-meta-item-icon"><i class="fa fa-keyboard-o"></i><span class="post-count"> 2.5k</span><span class="post-meta-item-text"> Words</span></span></span><span class="post-time"> | <span class="post-meta-item-icon"><i class="fa fa-clock-o"></i><span class="post-count"> 15</span><span class="post-meta-item-text"> Minutes</span></span></span></div><div class="post-content"><p><img src="/images/logicVSmalware/slides_01_1280x720.png" alt></p>
<h2 id="What-is-this-post-about"><a href="#What-is-this-post-about" class="headerlink" title="What is this post about?"></a>What is this post about?</h2><hr>
<p>Malicious codes are implemented to stay hidden during the infection and operation, preventing their removal and the analysis of the code. Software analysis is a critical point in dealing with malware, since most samples employ some sort of packing or obfuscation techniques in order to thwart analysis. <a id="more"></a>It is also an area of economic concern in protecting digital assets from intellectual property theft. Static analysis tools help analysts identifying vulnerabilities and issues before they cause harm downstream. Understanding how malware works beyond standard debuggers and sandboxes gives us insights and show us how to best protect others. In this year VB conference I gave an introduction on some practical applications of SMT solvers in IT security, investigating the theoretical limitations and practical solutions, focusing on their use as a tool for binary static analysis.</p>
<p>This work is about :</p>
<ul>
<li>constraint logic programming (CLP)</li>
<li>solvers</li>
<li>malware RE challenges</li>
<li>Logic vs. Malware</li>
</ul>
<h3 id="S-A-M-What"><a href="#S-A-M-What" class="headerlink" title="S..A..M.. What?"></a>S..A..M.. What?</h3><hr>
<p><img src="/images/logicVSmalware/slides_11_1280x720.png" alt></p>
<p>The satisfiability problem (SAT) asks whether the variables of a given Boolean formula (or a model) can be consistently replaced by the values 1 (or TRUE) or 0 (FALSE) in such a way that the formula evaluates to 1 (TRUE), or satisfiable. The issue here is that SAT is a NP-complete problem and like all other problems in this same complexity class, there is no efficient algorithm for solving SAT problems (that we know about!). However, SAT solvers are efficient enough for most of industrial problems and when not, we can still translate the problem into a combinatorial problem. As a result, they are frequently used as the “engine” behind various code verification applications.</p>
<p>Moreover, systems are usually designed and modeled at a higher level than the Boolean level and the translation to Boolean logic can be expensive. A primary goal of research in Satisfiability Modulo Theories (SMT) is to create verification engines that can reason natively at a higher level of abstraction, while still retaining the speed and automation of today’s Boolean engines.</p>
<h3 id="Constraints"><a href="#Constraints" class="headerlink" title="Constraints"></a>Constraints</h3><hr>
<blockquote>
<p>“Constraint programming represents one of the closest approaches computer science has yet made to the Holy Grail of programming: the user states the problem, the computer solves it.”<br>Eugene C. Freuder, Constraints, April 1997</p>
</blockquote>
<p>Constraint Programming is nothing more than someone / something stating constraints about problem variables and finding solution which satisfies all the constraints. Of course there is a theoretical limitation when thinking about general computing problems BUT over 90% of all constraint satisfaction problems in industrial applications are finite domains problems and therefore they can be written as combinatorial problems.</p>
<h3 id="Automated-Theorem-Proving"><a href="#Automated-Theorem-Proving" class="headerlink" title="Automated Theorem Proving"></a>Automated Theorem Proving</h3><hr>
<p><img src="/images/logicVSmalware/slides_18_1280x720.png" alt></p>
<p>If you want to know more about logical programming, you can go around and check the other posts I have in here and I mean, this is the InternetZ, right? But for now, we can see the SMT solver as a blackbox. You feed it with a theory, which includes the problem, your start conditions and the goal you want to achieve and the “engine” inside of it will deal with the logical connections. If the engine finds a possible solution to your problem considering ALL the constrains, it will return the answer “FEASIBLE”. More than that, it will also return how to get from your problem to your desired solution! Each of this possibilities are called <em>Instance of quantified axioms</em>.</p>
<p>It is easier to understand how this blackbox works, if we know who designed it in first place. So, who wants so badly to PROVE things? In the past Mathematicians, nowadays also computer scientists working on hardware and software verification. This kind of automation was used to make the life of mathematicians a bit easier, making it possible to state (and prove) thousands of tiny theorems leading to the biggest (or highest) goal. And there is no reason for the computer scientists to not use the solvers in the same way making large-scale verification of hardware and software accessible and more reliable, defining formulas which imply the correctness of the program.</p>
<h3 id="Symbolic-Execution"><a href="#Symbolic-Execution" class="headerlink" title="Symbolic Execution"></a>Symbolic Execution</h3><hr>
<p>Symbolic Execution automatically explores all program paths to determine which inputs cause each part of a program to execute. Combined with SMT Solvers which will reason about either the path is going to be takes at any given time or not, we - analysts - are able to get 100 % code coverage of the actual malware code.</p>
<h4 id="It-looks-like-that"><a href="#It-looks-like-that" class="headerlink" title="It looks like that"></a>It looks like that</h4><p><img src="/images/logicVSmalware/slides_20_1280x720.png" alt></p>
<p>In a theoretical approach, one can say you are extending the language accepted by the Turing machine with symbolic values, which represent the unknown / possible states. Then all possible execution paths will be explored and for each path the branching constraints are collected. After that, it is possible to generate input-tests based on the collected path constraints.</p>
<h3 id="How-it-works"><a href="#How-it-works" class="headerlink" title="How it works"></a>How it works</h3><hr>
<p>A simple algorithm could be:</p>
<ul>
<li>Create a process (pc = 0, state = [])</li>
<li>Add the process (pc, state) to the domain system D</li>
<li>while D not empty:<ul>
<li>Remove process (pc, state) from system</li>
<li>Execute it until the next branching point<ul>
<li>If both paths are feasible, add both to D</li>
<li>if just one is feasible, add the feasible path and the negation of the not feasible path to D</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>It is clear to see that symbolic execution has O(e^n), where n is the number of branching points, as the Symbolic Execution Algorithm forks at every branching point, in case both paths are feasible. This is why, while implementing it, it is better to check / reason about the branch during the execution, which can limit the deep of the execution and save time and memory. When one has all the information, it is possible to create a control flow graph (CFG).</p>
<p>The precision of the graph and the performance of the analysis depend on the options used to generate the control flow edges. The context sensitivity of the graph is an important parameter to consider for the matter of malware detection. The configuration of the precision parameters determines the representation of system calls on the graph. High context sensitivity enables cross references, when system calls are invoked in multiple locations. The nodes can then be differentiated by the invoking function, the parameters used for the invocation or the receiving function. Context sensitivity may also depend on the functions or calls themselves. Furthermore, that means that increasing context sensitivity results in a greater number of system call clones among the graph nodes.</p>
<h4 id="Keep-in-mind"><a href="#Keep-in-mind" class="headerlink" title="Keep in mind!"></a>Keep in mind!</h4><ul>
<li>Symbols as arguments<ul>
<li><strong>any</strong> feasible path</li>
<li><strong>all</strong> Program states</li>
</ul>
</li>
<li>Symbolic values <strong>also for memory allocations</strong></li>
<li>Path conditions</li>
</ul>
<h2 id="Application-in-Security"><a href="#Application-in-Security" class="headerlink" title="Application in Security"></a>Application in Security</h2><hr>
<p>The idea is pretty simple, as the solvers are kind of a model checking engine. One can define some safety properties naïve like <em>X is SAFE = NOTHING BAD EVER happens</em>. This way, one can infer that the model <em>M</em> is a transition. To check, if <em>M</em> is safe in <em>P</em> (P being a state property), it computes all reachable states <em>R</em> and then calculate the intersection between <em>R</em> and <em>P</em>, which should be the empty set (not existent). We could also represent <em>M</em> symbolically and use other automata-based methods. People are using SMT solvers in different fields, these are only some examples:</p>
<h3 id="Bug-Hunting"><a href="#Bug-Hunting" class="headerlink" title="Bug Hunting"></a>Bug Hunting</h3><hr>
<img src="/images/bug-feature.png" style="width: 170px;">

<ul>
<li>Fuzzing</li>
<li>Code verification</li>
<li>Binary Analysis</li>
</ul>
<h3 id="Exploitation"><a href="#Exploitation" class="headerlink" title="Exploitation"></a>Exploitation</h3><hr>
<img src="/images/RonKaminsky.png" style="width: 170px;">

<ul>
<li>Proof of Concept</li>
<li>AEG</li>
<li>APG</li>
</ul>
<h3 id="Malware-analysis"><a href="#Malware-analysis" class="headerlink" title="Malware analysis"></a>Malware analysis</h3><hr>
<img src="/images/worm.png" style="width: 170px;">

<ul>
<li>Obfuscation</li>
<li>Compiler optimizations</li>
<li>Crypto-analysis</li>
</ul>
<h2 id="Binary-Obfuscation"><a href="#Binary-Obfuscation" class="headerlink" title="Binary Obfuscation"></a>Binary Obfuscation</h2><hr>
<p>One thing that made me fall in love with malware is its duality. Malware is technically and educationally really interesting and some techniques are not really different than things used for example on software protection systems. In both cases, there is a program that does something and somebody puts some stuff around that program to make it difficult to people that are not allowed to get access to this program to actually understand what is going on.</p>
<p><img src="/images/logicVSmalware/slides_31_1280x720.png" alt></p>
<p>In one case, the objective is to make the analysis of the program difficult so that malware analysts have a tough time figuring out what the malicious code does and of course how to stop or neutralized those actions. In the other case, the objective is to make the analysis of the program difficult so crackers have a tough time figuring out what the key check program does and how to neutralize those protections. An important thing about this is that malware development is illegal but software protection is perfectly legal. What lead us to the main difference that is what the protected program actually does. There is nothing wrong with a program that does disk management for you, but it is very bad if, instead of that, the program encrypts all the files in the computer and ask for ransom.</p>
<h2 id="Malware-Deobfuscation"><a href="#Malware-Deobfuscation" class="headerlink" title="Malware Deobfuscation"></a>Malware Deobfuscation</h2><hr>
<p><img src="/images/logicVSmalware/slides_36_1280x720.png" alt></p>
<p>The implementation of obfuscation can be as simple as a few bit manipulations - like binary Xor - and as advanced as cryptographic standards (i.e. DES, AES, etc). In the world of malware, it’s useful to hide significant words the program uses (called “strings”) because they give insight into the malware’s behavior. Examples of said strings to hide would be malicious URLs or registry keys.</p>
<h3 id="Obfuscation-techniques"><a href="#Obfuscation-techniques" class="headerlink" title="Obfuscation techniques"></a>Obfuscation techniques</h3><hr>
<p><img src="/images/logicVSmalware/slides_37_1280x720.png" alt></p>
<p>An easy way to obfuscate code or make the binary code looks complex is the implementation of “while” or “go to” checks that are always true for example, creating an amount of called “garbage code”. Such code is mostly generated by the compiler, if you just give the command “No Optimization”. Using SMT solvers, it is possible to check each of the basic blocks, looking for ways of simplify the code if the constraint match. With aid of symbolic execution we can also check for unused branching points or unreachable code. Another exclusive or operation (represented as XOR) is probably the most commonly used method of obfuscation. This is because it is very easy to implement and easily hides your data from untrained eyes. Using SMT solvers and logical programming, it is possible to easily create a tool that will check for possible keys of the XOR function. Each possible key will be one instance of the SMT solver solution set. The XOR function is our theory and the SMT solver will check if it is feasible to get readable strings, for example, from the bytes that we have. But remember:</p>
<p><img src="/images/xor.jpg" alt></p>
<h3 id="For-packers’-sake"><a href="#For-packers’-sake" class="headerlink" title="For packers’ sake"></a>For packers’ sake</h3><hr>
<p><img src="/images/logicVSmalware/slides_39_1280x720.png" alt></p>
<p>And sometimes malware writers go a step further and obfuscate the entire file with a special program called a packer. Using SMT solvers it is also possible to unpack the code without needing to actually run it, avoiding the cases where the actually malicious code is inside the self implemented packer. This is possible because the SMT solver will give us instances of possible unpacked code. (Yes, I am saying static generic unpacking - fancy right?)</p>
<h2 id="Implementation"><a href="#Implementation" class="headerlink" title="Implementation"></a>Implementation</h2><hr>
<p><img src="/images/logicVSmalware/slides_41_1280x720.png" alt></p>
<p>There is a control flow implementation of all the conditional jump instructions which takes the 2 operands to compare, the conditional operand and the location operand. The SMT solver will reason about the conditional operand against the two comparison operands and if the condition is met, it will set the EIP to the value of the location operand. Otherwise it will go to the next instruction. If one of the condition is impossible to meet (the false or the true), the solver will remove the whole path starting from that branching point.</p>
<!-- ![](/images/logicVSmalware/slides_43_1280x720.png)

... are all implemented.

![](/images/logicVSmalware/slides_44_1280x720.png)

... are kind of implemented ;) -->

<h2 id="Limitations"><a href="#Limitations" class="headerlink" title="Limitations"></a>Limitations</h2><hr>
<h3 id="Theoretical"><a href="#Theoretical" class="headerlink" title="Theoretical"></a>Theoretical</h3><hr>
<p><img src="/images/RiceTheoremStatement.png" alt></p>
<p>The Rice’s theorem postulates that whatever properties of programs we are interest in, no other program can tell us, if this property holds for every program. We can reduce the Rice’s theorem to the Halting problem. The Halting problem postulates, that we cannot know if the computation of a program on some input will ever terminate. The importance of the undecidability of the Halting problem lies in its generality. A device that is capable of computing the solution to any problem that can be computed, provided that the device is given enough storage and time for the computation to finish, is defined as universal computing machine - also known as Turing machine. Turing also conjectured that his definition of computable was identical to the ’natural’ definition evinces that if a problem cannot be solved by a Turing machine also it cannot be solved in any other systematic manner.</p>
<h3 id="Practical"><a href="#Practical" class="headerlink" title="Practical"></a>Practical</h3><hr>
<p><img src="/images/code_obfuscation.png" alt><!-- .element height="65%" width="65%" --></p>
<p>The precision of the graph and the performance of the analysis depend on the options used to generate the control flow edges. The context sensitivity of the graph is an important parameter to consider for the matter of malware detection. The configuration of the precision parameters determines the representation of system calls on the graph. High context sensitivity enables cross references, when system calls are invoked in multiple locations. The nodes can then be differentiated by the invoking function, the parameters used for the invocation or the receiving function. Context sensitivity may also depend on the functions or calls themselves. Furthermore, that means that increasing context sensitivity results in a greater number of system call clones among the graph nodes. Accordingly, it also directly increases the analysis precision. However, the graph construction may become exponentially resource expensive for the processor.</p>
<p>In most of the cases, static analysis is a balance between wanted or needed precision and availability of resources. This process is repeated for all paths acquired. Afterwards, a set of satisfiable formulas is generated. Each of the satisfiable formulas in this set represents a trigger condition of a new discovered path. Each of these paths depends on the system calls. Hence, the solver is able to build the trigger values - that means, the used system calls - and the values for the trigger inputs, which are necessary to observe the malicious code.</p>
<h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><hr>
<h3 id="Learnings-Take-away"><a href="#Learnings-Take-away" class="headerlink" title="Learnings / Take away"></a>Learnings / Take away</h3><hr>
<p><img src="/images/boom.jpeg" alt></p>
<ul>
<li>Symbolic execution is a powerful tool while analysing malware</li>
<li>SMT solvers can be used to simplify CFG and support analysts while reversing</li>
</ul>
<p>SMT solvers are becoming an integral part of security engineer’s tool kit. I hope more people can see why solvers do a remarkable job in assisting malware analysts. The support in deciding whether suggested solutions are valid in their respective problem space saves economical resources and time of experts. Solvers support analysts looking for code vulnerabilities and analysing malicious code, detecting vulnerabilities in web applications and breaking encryptions. Yet, solvers are not suited for generating domain-specific problem descriptions. The preliminary constraint generation step still has to be performed outside the solver.</p>
<h3 id="Work-done"><a href="#Work-done" class="headerlink" title="Work done:"></a>Work done:</h3><hr>
<p><img src="/images/done.jpeg" alt></p>
<ul>
<li>a binary garbage-code eliminator for malware analysis,</li>
<li>a XOR search,</li>
<li>some cryptographic algorithm breaker,</li>
<li>a generic unpacker,</li>
<li>a binary structure recognizer,</li>
<li>a C++ class hierarchy reconstructor.</li>
</ul>
<h3 id="Working-on-…"><a href="#Working-on-…" class="headerlink" title="Working on …"></a>Working on …</h3><hr>
<p><img src="/images/quests.jpeg" alt></p>
<ul>
<li>r2 integration,</li>
<li>maybe IDA-Plugin.</li>
</ul>
<p>On other matters I am also working on building a specialized constraint inference assistant, which will improve and help the generation of formal problem definitions for non-trivial problems in the area of computer security. And it is good to remember that improving the constraint generation phase making will make automated exploit generation finally practicable. Of course, improving SMT solvers in general would also mean a progress towards serial check and more secure cryptosystems.</p>
<hr>
<p>If you like this topic, you can find more information on my <a href="https://chaosdorf.de/~barbieauglend/Analysing-compiled-binaries-using-logic.pdf" target="_blank" rel="noopener">VB paper</a>!</p>
<p>You can also find the full slide deck <a href="https://chaosdorf.de/~barbieauglend/final_preso.pdf" target="_blank" rel="noopener">here</a>.</p>
</div><div class="post-copyright"><script type="text/javascript" src="/js/copyright.js" successtext="Copy Successed!"></script><link rel="stylesheet" type="text/css" href="/css/copyright.css"><p>this has been written by me for fun purposes, don't take it serious!</p></div><br><div class="tags"><a href="/tags/binary-analysis/"><i class="fa fa-tag"></i>binary analysis</a><a href="/tags/reversing/"><i class="fa fa-tag"></i>reversing</a><a href="/tags/smt-solvers/"><i class="fa fa-tag"></i>smt solvers</a><a href="/tags/malware/"><i class="fa fa-tag"></i>malware</a><a href="/tags/talks/"><i class="fa fa-tag"></i>talks</a></div><div class="post-nav"><a class="pre" href="/2019-04-28-first-steps-into-the-bios/">Learning about the BIOS</a><a class="next" href="/2018-08-03-firmware_101/">Firmware 101 - How to get the code</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> Tags</i></div><div class="tagcloud"><a href="/tags/prolog/" style="font-size: 15px;">prolog</a> <a href="/tags/low-level/" style="font-size: 15px;">low level</a> <a href="/tags/platform/" style="font-size: 15px;">platform</a> <a href="/tags/SMM/" style="font-size: 15px;">SMM</a> <a href="/tags/haskell/" style="font-size: 15px;">haskell</a> <a href="/tags/firmware/" style="font-size: 15px;">firmware</a> <a href="/tags/binary-analysis/" style="font-size: 15px;">binary analysis</a> <a href="/tags/reversing/" style="font-size: 15px;">reversing</a> <a href="/tags/hardware/" style="font-size: 15px;">hardware</a> <a href="/tags/smt-solvers/" style="font-size: 15px;">smt solvers</a> <a href="/tags/malware/" style="font-size: 15px;">malware</a> <a href="/tags/talks/" style="font-size: 15px;">talks</a> <a href="/tags/research/" style="font-size: 15px;">research</a> <a href="/tags/science/" style="font-size: 15px;">science</a> <a href="/tags/misc/" style="font-size: 15px;">misc</a> <a href="/tags/bios/" style="font-size: 15px;">bios</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> Recent</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2020-06-19-how-to-research/">How Do I Do Research?</a></li><li class="post-list-item"><a class="post-list-link" href="/2019-08-15-system-managing-god/">SMMMmmmm - when root is not enough</a></li><li class="post-list-item"><a class="post-list-link" href="/2019-04-28-first-steps-into-the-bios/">Learning about the BIOS</a></li><li class="post-list-item"><a class="post-list-link" href="/2018-10-03-logicvsmalware/">Logic & binaries</a></li><li class="post-list-item"><a class="post-list-link" href="/2018-08-03-firmware_101/">Firmware 101 - How to get the code</a></li><li class="post-list-item"><a class="post-list-link" href="/2018-07-23-hardware_101/">Hardware 101 - I have this $device... and now?</a></li><li class="post-list-item"><a class="post-list-link" href="/2018-07-20-genRE/">/me on reverse engineering</a></li><li class="post-list-item"><a class="post-list-link" href="/2018-07-06-memory_skrolli/">Tinkering the memory</a></li><li class="post-list-item"><a class="post-list-link" href="/2018-07-03-hsandprolog/">Prolog vs Haskell</a></li><li class="post-list-item"><a class="post-list-link" href="/2018-06-09-prolog08/">PROLOG - Part 8</a></li></ul></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2025 <a href="/." rel="nofollow">barbie's notes.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=1.0.1" async></script><script type="text/javascript" src="//cdn.jsdelivr.net/gh/fancyapps/fancybox/dist/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=1.0.1" async></script><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox/dist/jquery.fancybox.min.css"><script type="text/javascript" src="/js/love.js"></script><script type="text/javascript" src="/js/copycode.js" successtext="Copy Successed!"></script><link rel="stylesheet" type="text/css" href="/css/copycode.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.1"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.1"></script></div></body></html>