<!DOCTYPE html><html lang="en"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>SMMMmmmm - when root is not enough | barbie's notes</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.1"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/normalize.css/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/purecss/build/pure-min.min.css"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/purecss/build/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.jsdelivr.net/npm/jquery/dist/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><script type="text/javascript" src="//cdn.jsdelivr.net/npm/clipboard/dist/clipboard.min.js"></script><script type="text/javascript" src="//cdn.jsdelivr.net/gh/codeseven/toastr/build/toastr.min.js"></script><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/codeseven/toastr/build/toastr.min.css"><link rel="stylesheet" href="/css/prism.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">SMMMmmmm - when root is not enough</h1><a id="logo" href="/.">barbie's notes</a><p class="description">my not-professional-at-all blog</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> start</i></a><a href="/archives/"><i class="fa fa-archive"> oldies</i></a><a href="/about/"><i class="fa fa-user"> /me</i></a><a href="/talks/"><i class="fa fa-users"> IRL</i></a><a href="/credits/"><i class="fa fa-heart"> credits</i></a><a href="/atom.xml"><i class="fa fa-rss"> RSS</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">SMMMmmmm - when root is not enough</h1><div class="post-meta">2019-08-14<span class="post-time"><span class="post-meta-item-text"> | </span><span class="post-meta-item-icon"><i class="fa fa-keyboard-o"></i><span class="post-count"> 1.8k</span><span class="post-meta-item-text"> Words</span></span></span><span class="post-time"> | <span class="post-meta-item-icon"><i class="fa fa-clock-o"></i><span class="post-count"> 11</span><span class="post-meta-item-text"> Minutes</span></span></span></div><div class="post-content"><h2 id="Swimming-Diving-Hopefully-not-Drowning"><a href="#Swimming-Diving-Hopefully-not-Drowning" class="headerlink" title="Swimming, Diving, Hopefully not Drowning!"></a>Swimming, Diving, Hopefully not Drowning!</h2><p>I got a super nice project, and for that I needed to learn how the SMM really works. Again I started dipping my toes in this ocean of knowledge and I hope I don’t get too excited and drown myself before even getting started ;) For the people who are not sure if they want to read all this:</p>
<h2 id="TL-DR"><a href="#TL-DR" class="headerlink" title="TL;DR"></a>TL;DR</h2><p>In SMM, it is possible to modify SMM saved execution context. SMM also sets its own IDT, it is initialized by the BIOS (DXE) and tons of cool stuff. <a id="more"></a> Normally, CS base address is system-management RAM (SMRAM) base address and SMM code is copied to SMRAM in UEFI initialization and SMRAM is locked right after for security reasons.</p>
<p>Why use SMM? Whenever we have anything …</p>
<ul>
<li><p>So important, we don’t want the kernel to screw it up</p>
</li>
<li><p>So secret, it needs to be hidden from the OS and inaccessible from direct memory access (DMA)</p>
</li>
<li><p>So sensitive, it should never be touched by anyone</p>
<p>… it is better to toss it into SMM ftw.</p>
</li>
</ul>
<h2 id="The-System-Management-Mode"><a href="#The-System-Management-Mode" class="headerlink" title="The System Management Mode"></a>The System Management Mode</h2><p>The System Management Mode, widely know as SMM, is not just yet another CPU operating mode. It is a very special small piece of technology that handles system-wide stuff. It was initially developed to handle power management ie - a resource constrained processor environment which is supposed to be transparent and isolated, used only by the system firmware (yeah, no software access intended!).</p>
<p>Somehow most of the BIOS researchers want to get access to SMM… Why? As researchers in the past has shown<sup><a href="#SMMDesign">1</a></sup><sup><a href="#XEN">2</a></sup><sup><a href="#UEFI">3</a></sup><sup><a href="#Cache">4</a></sup>, attackers gaining control over SMM may potentially, in an oversimplified way, modify all physical memory, install kernel backdoors or even change the configuration of the hardware stealthily from the OS point of view. Interesting enough, in UEFI some important security features implementations use SMM, for example protecting the firmware image inside the flash.</p>
<p>To access the SMM environment, a hardware non-maskable interrupt is used - I am going to get into more details further down, and but the thing to remember is: this interrupt has higher priority levels than OS kernel or even hypervisors.</p>
<h2 id="The-System-Management-Interrupt-SMI"><a href="#The-System-Management-Interrupt-SMI" class="headerlink" title="The System Management Interrupt (SMI)"></a>The System Management Interrupt (SMI)</h2><blockquote>
<p>The access to SMI is done through the SMI# pin on the processor or through an SMI message received through the <a href="/2019-07-02-interesting-interrupts/#Programmable-Interrupt-Controller">APIC</a> bus. The SMI is a non-maskable external interrupt that operates independently from the processor’s interrupt- and exception-handling mechanism and the local APIC. The SMI takes precedence over an <a href="https://en.wikipedia.org/wiki/Non-maskable_interrupt" target="_blank" rel="noopener">non-maskable interrupt</a> (NMI) and a <a href="/2019-07-02-interesting-interrupts">maskable interrupt</a>.<br>– <cite><a href="#IntelSDM">Intel SDM</a></cite></p>
</blockquote>
<p>As you see, the SMI is generated by the chipset. To trigger it, we need to modify the Advanced Power Management Control (APMC) register.</p>
<h3 id="In-and-Out-of-the-SMM"><a href="#In-and-Out-of-the-SMM" class="headerlink" title="In and Out of the SMM"></a>In and Out of the SMM</h3><p>As I stated in the beginning, we can enter the SMM only through SMI. When SMI is invoked, the processor will backup its context and switch to a new, separated and (hopefully!) inaccessible address space environment. The SMI handler is executed inside this environment and all OS’s interrupts are disabled. SMI can be signaled from real-addresses, protected or virtual mode.</p>
<p>Also interesting is that the CR4 register gets cleared - yes, all turned to zero - when entering SMM.</p>
<p>If a second SMI occurs while in SMM, it will be latched and executed as soon as a SMM exits occurs, usually with a RSM (resume) instruction call. Only one SMI can be latched, all other subsequent SMIs will be discarded.</p>
<p>The handler finishes its operations with a RSM instruction, which exists only in the SMM context. An attempt to execute the RSM instruction outside of the SMM context results in an invalid-opcode exception (#UD). The RSM instruction reloads the saved process context, switches back to the mode it was in when the SMI was called, the processor returns an SMIACK (the signal of SMI acknowledgment signal on return) on the system bus and resumes execution on the interrupted task.</p>
<h3 id="The-Shutdown-State"><a href="#The-Shutdown-State" class="headerlink" title="The Shutdown State"></a>The Shutdown State</h3><p>If something weird in the SMRAM is detected by the processor, the dumbed <em>shutdown state</em> is called and a special bus cycle is generated. When the processor is in shutdown state, no instructions are executed until a RESET, INIT or NMI is asserted.</p>
<h2 id="Inside-the-SMM-SMRAM"><a href="#Inside-the-SMM-SMRAM" class="headerlink" title="Inside the SMM - SMRAM"></a>Inside the SMM - SMRAM</h2><p>The SMI handler is executed inside the SMM and all critical information (code &amp; data) lives in the SMRAM within this reserved address space created upon entry.</p>
<p>The SMRAM can be located in Compatible Memory Segment (CSEG), High Memory Segment (HSEG) or Top of Memory Segment (TSEG) system memory regions, depending on the hardware / platform you have. Normally BIOS developers would use CSEG. Nowadays UEFI developers mostly use HSEG and TSEG, since they offer 8MB of cacheable memory, giving them more freedom to architecture more complex drivers inside SMM. Look for the datasheet specific for your platform for the nitty-gritty details.</p>
<p>The interesting thing about TSEG is that no software can access it directly but it is possible to calculate where it is located:</p>
<p>TSEG ADDR = Top of Low Usable DRAM (TOLUD) - Size of Data of stolen memory (DSM SIZE) -  size of GTT stolen memory (GSM SIZE) - size of TSEG (we can also say Thaís segment bc you know…)</p>
<blockquote>
<p>There’s also other registers that should be properly configured and locked by firmware to protect SMRAM from various attacks:</p>
<ul>
<li>Top of Upper Usable DRAM (TOUUD), Top of Low Usable DRAM (TOLUD), REMAPLIMIT and REMAPBASE registers that used to configure physical memory map must be locked by firmware to protect SMRAM from memory remapping attacks. For more information check “<a href="http://www.ssi.gouv.fr/uploads/IMG/pdf/IT_Defense_2010_final.pdf" target="_blank" rel="noopener">System Management Mode Design and Security Issues</a>“ and “<a href="http://www.invisiblethingslab.com/resources/bh08/part2-full.pdf" target="_blank" rel="noopener">Preventing and Detecting Xen Hypervisor Subversions</a>“.</li>
<li>TSEGMB register defines address of memory region that should be protected from DMA access, firmware must configure and lock it. For more information check “<a href="https://bromiumlabs.files.wordpress.com/2015/01/venamis_whitepaper.pdf" target="_blank" rel="noopener">Attacking UEFI Boot Script</a>“.</li>
<li>System Management Range Registers (SMRR) — a pair of IA32_SMRR_PHYSBASE and IA32_SMRR_PHYSMASK MSRs that can be modified only by SMM, TXT and ACM code. Because HSEG and TSEG memory is cacheable — SMRR must be configured to protect it from SMM cache poisoning attacks. For more information check “<a href="http://www.invisiblethingslab.com/resources/misc09/smm_cache_fun.pdf" target="_blank" rel="noopener">Attacking SMM Memory via Intel CPU Cache Poisoning</a>“.</li>
</ul>
<p>– <cite><a href="#Cr4sh">Cr4sh</a></cite></p>
</blockquote>
<p>The default SMRAM size is 64 KBytes and begins at the SMBASE address (0x30000 at the hardware reset, commonly seen at 0xA0000 as BIOS relocates it to the video card I/O ports). A larger area can be decoded, if needed, varying from 32KBytes to 4GBytes. The SMBASE address can also be changed. The default layout looks like this:</p>
<table>
<thead>
<tr>
<th align="center"><img src="/images/SMRAM.png" alt="SMRAM default layout"></th>
</tr>
</thead>
<tbody><tr>
<td align="center"><em>SMRAM default layout - source: Intel SDM</em></td>
</tr>
</tbody></table>
<p>Standard operations which are handled by SMM would be power management of different devices / drivers, the execution of proprietary code like from OEMs and many other cool and sensitive stuff. Also all I/O and system instructions are available.</p>
<p>SMM code can read and modify all the saved execution context, since it lives inside SMRAM. Also SMM sets its own IDT and all, so it is the special kid in the gated community. You got the idea.</p>
<p><em>Important: Initially all the addresses are real address mode and paging is disabled (CR0.PE and CR0.PG are set to 0). The operating mode can be switched afterwards while remaining in the SMM.</em></p>
<h3 id="Triggering-a-SMI"><a href="#Triggering-a-SMI" class="headerlink" title="Triggering a SMI"></a>Triggering a SMI</h3><p>There are several ways to generate SMI:</p>
<ul>
<li>Ring 0 code can trigger software SMI at any time by writing some byte value to APMC I/O port 0xb2</li>
<li>I/O instruction restart CPU feature allows to generate SMI on any I/O port access by IN or OUT processor instruction</li>
<li>Some are accessible via PCI internal chipset registers</li>
<li>You can also send IPI via APIC specifying #SMI :)</li>
</ul>
<h2 id="SMM-Start"><a href="#SMM-Start" class="headerlink" title="SMM Start"></a>SMM Start</h2><p>The SMM services are started during the platform initialization. To be more specific, when the board initializes the boot services, the DXE (Driver execution environment) dispatcher will call the SMM initial program loader. The IPL (Initial Program Load) will load the SMM services into the SMRAM and it will keep it running until a platform shutdown. SMBASE <a href="https://en.wikipedia.org/wiki/Model-specific_register" target="_blank" rel="noopener">MSR</a> can be read only in SMM and is different per CPU thread and BIOS implementation.</p>
<h2 id="The-SMM-transfer-Monitor"><a href="#The-SMM-transfer-Monitor" class="headerlink" title="The SMM-transfer Monitor"></a>The SMM-transfer Monitor</h2><p>The SMM-transfer monitor (STM) is a virtual machine monitor (VMM) working inside the SMM. STM is stored in a special region inside SMRAM called MSEG (Monitor Segment). A 4G 1:1 mapping page table for the STM x64 mode is generated.</p>
<h2 id="Between-SMM-and-Non-SMM-Data"><a href="#Between-SMM-and-Non-SMM-Data" class="headerlink" title="Between SMM and Non-SMM Data"></a>Between SMM and Non-SMM Data</h2><p>The main job of the BIOS is to initialize the platform and to communicate with an OS. Some BIOS provide also some services to the OS like runtime services and SMI handlers.</p>
<p>But there is no Intel definition on how the data transfer from non-SMM to SMM should be. This is why the UEFI Forum has defined two generic ways for the communication between OS and BIOS SMI handler. It is important to notice and remember, that OEM BIOS can also define their own protocol for communication. I am studying the UEFI BIOS, which is the state of art.</p>
<h3 id="How-to-Communicate"><a href="#How-to-Communicate" class="headerlink" title="How to Communicate"></a>How to Communicate</h3><p>The UEFI specification defines the EFI_SM_COMMUNICATION_PROTOCOL, which provides runtimes services for communicating between drivers outside of SMM and a register SMI handler inside of SMM.</p>
<p>Some BIOS drivers which are consuming this protocol would be BIOS DXE driver, the BIOS runtime driver and even the OS agent.</p>
<h2 id="SMRAM-Control-SMRAMC-register"><a href="#SMRAM-Control-SMRAMC-register" class="headerlink" title="SMRAM Control (SMRAMC) register"></a>SMRAM Control (SMRAMC) register</h2><p>SMRAMC controls the presence of CSEG/HSEG/TSEG regions and their accessibility from less privileged than SMM execution modes. Here’s the description of its bits:</p>
<p><img src="/images/smramc.png" alt="img"></p>
<p>System firmware sets SMRAMC value during platform initialization and locks the register — all fields becomes read-only till the next full reset. On properly configured system D_LCK must be 1 and D_OPEN must be 0, which means that SMRAM memory will be accessible only from code that runs in SMM or higher (like an ACM). G_SMRAME field controls presence of CSEG and C_BASE_SEG is responsible for HSEG and TSEG. On my hardware C_BASE_SEG is read-only with a predefined value of 010b.</p>
<h2 id="TBC"><a href="#TBC" class="headerlink" title="TBC"></a>TBC</h2><p>I am probably going to write more about SMM later on, keep tuned!</p>
<h5 id="Good-to-Know"><a href="#Good-to-Know" class="headerlink" title="Good to Know:"></a>Good to Know:</h5><ul>
<li><a href="https://en.wikipedia.org/wiki/Memory_type_range_register" target="_blank" rel="noopener">MTRR - Memory type range register</a></li>
<li><a href="https://en.wikipedia.org/wiki/I/O_Controller_Hub" target="_blank" rel="noopener">ICH - I/O Control Hub</a></li>
</ul>
<h5 id="Source"><a href="#Source" class="headerlink" title="Source:"></a>Source:</h5><p><a name="IntelSDM"></a> <em>Intel® 64 and IA-32 Architectures Software Developer Manuals</em><br><a href="https://software.intel.com/en-us/articles/intel-sdm#combined" target="_blank" rel="noopener">https://software.intel.com/en-us/articles/intel-sdm#combined</a></p>
<p><a name="Cr4sh"></a> <em>Building reliable SMM backdoor for UEFI based platforms (and others!!)</em> <a href="http://blog.cr4.sh/2015/07/building-reliable-smm-backdoor-for-uefi.html" target="_blank" rel="noopener">http://blog.cr4.sh/2015/07/building-reliable-smm-backdoor-for-uefi.html</a></p>
<p><a name="Xeno"></a> <em>Introduction to BIOS &amp; SMM</em> <a href="http://opensecuritytraining.info/IntroBIOS.html" target="_blank" rel="noopener">http://opensecuritytraining.info/IntroBIOS.html</a></p>
<p><a name="SMMDesign"></a> <em>System Management Mode Design and Security Issues</em><br><a href="http://www.ssi.gouv.fr/uploads/IMG/pdf/IT_Defense_2010_final.pdf" target="_blank" rel="noopener">http://www.ssi.gouv.fr/uploads/IMG/pdf/IT_Defense_2010_final.pdf</a></p>
<p><a name="XEN"></a> <em>Preventing and Detecting Xen Hypervisor Subversions</em><br><a href="http://www.invisiblethingslab.com/resources/bh08/part2-full.pdf" target="_blank" rel="noopener">http://www.invisiblethingslab.com/resources/bh08/part2-full.pdf</a></p>
<p><a name="UEFI"></a> <em>Attacking UEFI Boot Script</em><br><a href="https://bromiumlabs.files.wordpress.com/2015/01/venamis_whitepaper.pdf" target="_blank" rel="noopener">https://bromiumlabs.files.wordpress.com/2015/01/venamis_whitepaper.pdf</a></p>
<p><a name="Cache"></a> <em>Attacking SMM Memory via Intel CPU Cache Poisoning</em><br><a href="http://www.invisiblethingslab.com/resources/misc09/smm_cache_fun.pdf" target="_blank" rel="noopener">http://www.invisiblethingslab.com/resources/misc09/smm_cache_fun.pdf</a></p>
</div><div class="post-copyright"><script type="text/javascript" src="/js/copyright.js" successtext="Copy Successed!"></script><link rel="stylesheet" type="text/css" href="/css/copyright.css"><p>this has been written by me for fun purposes, don't take it serious!</p></div><br><div class="tags"><a href="/tags/low-level/"><i class="fa fa-tag"></i>low level</a><a href="/tags/platform/"><i class="fa fa-tag"></i>platform</a><a href="/tags/SMM/"><i class="fa fa-tag"></i>SMM</a></div><div class="post-nav"><a class="pre" href="/2020-06-19-how-to-research/">How Do I Do Research?</a><a class="next" href="/2019-04-28-first-steps-into-the-bios/">Learning about the BIOS</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> Tags</i></div><div class="tagcloud"><a href="/tags/ctf/" style="font-size: 15px;">ctf</a> <a href="/tags/Challenge-Cyber-Sec/" style="font-size: 15px;">Challenge Cyber Sec</a> <a href="/tags/prolog/" style="font-size: 15px;">prolog</a> <a href="/tags/low-level/" style="font-size: 15px;">low level</a> <a href="/tags/platform/" style="font-size: 15px;">platform</a> <a href="/tags/system/" style="font-size: 15px;">system</a> <a href="/tags/SMM/" style="font-size: 15px;">SMM</a> <a href="/tags/God-mode/" style="font-size: 15px;">God mode</a> <a href="/tags/haskell/" style="font-size: 15px;">haskell</a> <a href="/tags/internals/" style="font-size: 15px;">internals</a> <a href="/tags/analysis/" style="font-size: 15px;">analysis</a> <a href="/tags/reverse-engineering/" style="font-size: 15px;">reverse engineering</a> <a href="/tags/firmware/" style="font-size: 15px;">firmware</a> <a href="/tags/binary-analysis/" style="font-size: 15px;">binary analysis</a> <a href="/tags/reversing/" style="font-size: 15px;">reversing</a> <a href="/tags/hardware/" style="font-size: 15px;">hardware</a> <a href="/tags/smt-solvers/" style="font-size: 15px;">smt solvers</a> <a href="/tags/malware/" style="font-size: 15px;">malware</a> <a href="/tags/talks/" style="font-size: 15px;">talks</a> <a href="/tags/research/" style="font-size: 15px;">research</a> <a href="/tags/science/" style="font-size: 15px;">science</a> <a href="/tags/misc/" style="font-size: 15px;">misc</a> <a href="/tags/bios/" style="font-size: 15px;">bios</a> <a href="/tags/interrupt/" style="font-size: 15px;">interrupt</a> <a href="/tags/exception/" style="font-size: 15px;">exception</a> <a href="/tags/handler/" style="font-size: 15px;">handler</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> Recent</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2020-06-19-how-to-research/">How Do I Do Research?</a></li><li class="post-list-item"><a class="post-list-link" href="/2019-08-15-system-managing-god/">SMMMmmmm - when root is not enough</a></li><li class="post-list-item"><a class="post-list-link" href="/2019-04-28-first-steps-into-the-bios/">Learning about the BIOS</a></li><li class="post-list-item"><a class="post-list-link" href="/2018-10-03-logicvsmalware/">Logic & binaries</a></li><li class="post-list-item"><a class="post-list-link" href="/2018-08-03-firmware_101/">Firmware 101 - How to get the code</a></li><li class="post-list-item"><a class="post-list-link" href="/2018-07-23-hardware_101/">Hardware 101 - I have this $device... and now?</a></li><li class="post-list-item"><a class="post-list-link" href="/2018-07-20-genRE/">/me on reverse engineering</a></li><li class="post-list-item"><a class="post-list-link" href="/2018-07-06-memory_skrolli/">Tinkering the memory</a></li><li class="post-list-item"><a class="post-list-link" href="/2018-07-03-hsandprolog/">Prolog vs Haskell</a></li><li class="post-list-item"><a class="post-list-link" href="/2018-06-09-prolog08/">PROLOG - Part 8</a></li></ul></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2025 <a href="/." rel="nofollow">barbie's notes.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=1.0.1" async></script><script type="text/javascript" src="//cdn.jsdelivr.net/gh/fancyapps/fancybox/dist/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=1.0.1" async></script><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox/dist/jquery.fancybox.min.css"><script type="text/javascript" src="/js/love.js"></script><script type="text/javascript" src="/js/copycode.js" successtext="Copy Successed!"></script><link rel="stylesheet" type="text/css" href="/css/copycode.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.1"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.1"></script></div></body></html>